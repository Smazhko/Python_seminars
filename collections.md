 ![заголовок](pthn.png) **`С П И С К И`**
=============================================

СПИСОК - изменяемый тип данных

Может содержать любые значения одновременно, в том числе другие списки любой степени вложения: список в списке в списке в списке.

    first_list = [9, 'fgdf', True, [1, 2, 3]]
    print(first_list)

### *Создание списков:*
    list_1 = []     
    list_2 = list()
    list_1 = [7, 9, 11, 13, 15, 17]

### *Операции со списками:*

    list_1[i] - i-тый элемент списка

    for element in list_1:
        print(element)

> **ВАЖНО:**  
> При обращении к элементам списка через **`FOR`** `element` **`IN`** `collection` изменение значения `element` никак не отобразится на самом списке. Для изменения значений в списке необходимо обращаться к элементу через индекс `collection[i]`. 

    list_1.append(n) -добавление в конец списка
    list1.insert(2, 11) - вставка нового элемента 11 в индекс 2

    list_1.pop()   # удаляет последний элемент и возвращает его
    list_1.pop(i)  # удаляет i-тый элемент и возвращает его

    list_1 = string.split('разделитель') # разделяет строку на элементы списка 
                            # если скобки пустые, разделитель по умолчанию - пробел 

    list_1.sort()  # можно сортировать только однотипные списки

* **`list.sort ()`** сортирует список на месте, изменяя его индексы и возвращая None, тогда как **`sorted()`** возвращает новый отсортированный список, оставляя исходный список неизменным. Другое отличие состоит в том, что **`sorted()`** принимает любые перечисляемые типы (коллекции), в то время как **`list.sort ()`** является методом класса списка и может использоваться только со списками.

* **`list.copy()`** копирует список, но без вложений других списков, если они были элементами первоначального списка

 ![заголовок](pthn.png) **`С Р Е З Ы`**
=======================================

    list_1 = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]

    print(list_1[0])                # 1й элемент
    print(list_1[1])                # 2й элемент
    print(list_1[len(list_1)-1])    # 1й с конца
    print(list_1[-5])               # 5й с конца
    print(list_1[:])                # ОТ начала ДО конца
    print(list_1[:2])               # [1, 2] - ОТ:ДО не включая
    print(list_1[len(list_1)-2:])   # ОТ 2го с конца ДО конца
    print(list_1[2:9])              # ОТ 2 ДО 9 НЕ ВКЛЮЧАЯ
    print(list_1[0:len(list_1):6])  # [1, 7] - от 0 до конца с шагом 6
    print(list_1[::6])              # [1, 7]

> ПРИМЕР: сдвинуть список на К элементов:

    list_1 = [1,2,3,4,5,6,7,8,9,0]
    k = 3
    print(list_1[k:] + list_1[:k]) # ВЫВОД: [4, 5, 6, 7, 8, 9, 0, 1, 2, 3]

 ![заголовок](pthn.png) **`К О Р Т Е Ж И`**
========================================

Кортеж `class <'tuple'> [tju:pl]` - неизменяемый список.
Могут хранить разные данные.
ПРИМЕНЕНИЕ:
* данные из бд на этапе загрузки
* лог пароль
* апи ключи
* всё, чему нужно гарантировать неизменяемость

Применяется в тех случаях, когда нужно гарантировать неизменяемость данных.
Обращение к элементам происходит по индексу (начиная с 0).

    first_typle = (9, 'fgdf', True, [1, 2, 3])

### *Создание кортежей:*
    t = ()       # создание пустого кортежа
    t = (1,)     # создание кортежа 
                 # ОБЯЗАТЕЛЬНО ЗАПЯТАЯ в конце, если 1 элемент

### *Операции с кортежами:*
    t = tuple(colors)                   # преобразование в кортеж
    t = tuple(['red', 'green', 'blue']) # преобразует список [] в кортеж
    r, g, b = t                         # РАЗЪЕДИНЯЕТ кортеж на переменные
    t = tuple(['red', 'green', 'blue'])

    print(t[0])                              # red
    print('r:{} g:{} b:{}'.format(r, g, b))  # r:red g:green b:blue

 ![заголовок](pthn.png) **`М Н О Ж Е С Т В А`**
======================================================

Множества содержат в себе уникальные элементы, не обязательно упорядоченные.
Изменяемый тип данных.
Можно посчитать и получить элемент с каким-то индексом

### *Операции с множествами:*

    colors = set()              # СОЗДАНИЕ пустого множества
    colors = {'red', 'green', 'blue'} # СОЗДАНИЕ и заполнение множества
    colors.add('red')           # ДОБАВЛЕНИЕ элемента (добавится в рандомный индекс)
                                # если элемент уже был, ничего не произойдет
    colors.remove('red')        # УДАЛЕНИЕ элемента
                                # при попытке удаления несуществующего KeyError: 'red'
    colors.discard('red')       # для удаления любого элемента, в т.ч. несуществ
    colors.clear()              # УДАЛЕНИЕ ВСЕХ элементов

    a = {1, 2, 3, 5, 8}
    b = {2, 5, 8, 13, 21}
    c = a.copy()            # КОПИРОВАНИЕ одного множества в другое
    u = a.union(b)          # ОБЪЕДИНЕНИЕ (сливание) двух множеств
    i = a.intersection(b)   # ПЕРЕСЕЧЕНИЕ - элементы, которые есть в обоих множ-вах
    dl = a.difference(b)    # РАЗНОСТЬ - то, что входит в А, но не входит в Б: 
                            # dl = {1, 3} 
    dr = b.difference(a)    # РАЗНОСТЬ - то, что входит в Б, но не входит в А: 
                            # dr = {13, 21}
    a.simmetrical_difference(b) # симметричная разность между множествами (всё, кроме общего)
    a.issubset(b)           # является ли одно множество подмножеством другого

    q=a.union(b).difference(a.intersection(b))      # {1, 21, 3, 13}

> ПРИМЕР: почистить список от дубликатов

    a = [1,1,1,1,1,5,5,5,5,5,7,4,7,8,8,8,8,7,7,4,4,5,5]
    print(list(set(a)))
    print(len(list(set(a))))

> Превратить в множество и превратить обратно в список.  
> РЕЗУЛЬТАТ: `[1, 4, 5, 7, 8]` КРУТОООООО !!!!!

## *`Неизменяемое или замороженное множество(frozenset)`* 
— множество, с которым не будут работать методы удаления и добавления.
    
    a = {1, 2, 3, 5, 8}
    b = frozenset(a)
    print(b) # frozenset({1, 2, 3, 5, 8})

 ![заголовок](pthn.png) **`С Л О В А Р И`**
===========================================

Словари — неупорядоченные коллекции произвольных объектов с доступом по ключу. 
Пара КЛЮЧ - ЗНАЧЕНИЕ
Типы ключей могут отличаться.

    first_dict = {'Mother': 123456789, 'Father': 987654321, 'Friend': 102030405}

Mother = ключ, 123456789 = значение  
Ключ - неизменяемый тип данный   
используется, например, для конфига, json   

    dictionary = {}             # создание пустого словаря
    dictionary = dict()         # создание пустого словаря
    dictionary = {'up': '↑', 'left': '←', 'down': '↓', 'right': '→'}
    print(dictionary)           # {'up':'↑', 'left':'←', 'down':'↓', 'right':'→'}

    print(dictionary['left'])   # ←
    dictionary['left'] = 'qwe'  # присваивание значения элементу под ключом 'left'
                                # если ключа 'left' раньше не было, он будет создан
    del dictionary['left']      # удаление ключа вместе с элементом
    
    dictionary.items()          # представление словаря в виде списка кортежей
                                # dict_items([(key, element), (key, element), ... ])
    dictionary.values()         # вывод ЗНАЧЕНИЙ всех ключей
                                # dict_values([elem, elem, elem, ...])
    dictionary.keys()           # вывод всех КЛЮЧЕЙ (индексов) словаря
                                # dict_keys(['key', 'key', 'key', ...])
    d = dictionary.copy()       # копирует словарь в какой-то новый
    dictionary.get('key')       # возвращает значение по ключу, если он есть. иначе пустоту?
    dictionary.clear()          # очистка словаря



    for item in dictionary:
    ИЛИ 
    for (k, v) in dictionary.items():
    print('{}: {}'.format(item, dictionary[item]))


![Сравнение коллекций](collections.jpg)


 ![заголовок](pthn.png) **`LIST COMPREHENSION`**
 =========================================================

**`List comprehension`** — это упрощенный подход к созданию списка, который
задействует цикл `for`, а также инструкции `if-else` для определения того, что в итоге
окажется в финальном списке.

Простая ситуация — список:

    list_1 = [выражение for item in iterable]  *iterable - любая коллекция

ГЕНЕРАТОР СЛОВАРЯ:   

    newDict = {key:value for item in list if conditional}

Выборка по заданному условию:  

    list_1 = [выражение for item in iterable (if условие)]
    list_1 = [i for i in range(1, 101)]                 # [1, 2, 3,..., 100]
    
**`if`** - накладывает условие на помещение введенного значения в собираемвй список 
(например, если указато условие БОЛЬШЕ НУЛЯ, то значения меньше/равно нуля в список не попадут)  

    newNewList = [int(a) for a in input().split() if int(a) > 0]

Создать пары каждому из чисел (кортежи):

    list_1 = [(i, i) for i in range(1, 101) if i % 2 == 0] # [(2, 2), (4, 4),...,
    (100, 100)]

Можно умножать, делить, прибавлять, вычитать. Например, умножить значение на 2.

    list_1 = [i * 2 for i in range(10) if i % 2 == 0]

 ![заголовок](pthn.png) **`ОШИБКИ  в PYTHON`**
 =============================================================

**`SyntaxError`**(Синтаксическая ошибка)
> Отсутствие двоеточия в конце строки

**`IndentationError`**(Ошибка отступов)
> Отсутствие отступов

**`TypeError`**(Типовая ошибка)
> Нельзя складывать строки и числа

**`ZeroDivisionError`**(Деление на 0)
> Деление на 0

**`KeyError`**(Ошибка ключа)
> Отсуствие ключа в словаре

**`NameError`**(Ошибка имени переменной)
> Переменной с указанным именем не существует

**`ValueError`**(Ошибка значения)
> Ошибка при невозможности преобразования одного типа в другой

