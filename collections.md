**`С П И С К И`**
============================
    list_1 = []     # Создание пустого списка
    list_2 = list() # Создание пустого списка
    list_1 = [7, 9, 11, 13, 15, 17]

    list_1[i] - i-тый элемент списка

    for element in list_1:
        print(element)

    list_1.append(n) -добавление в конец списка
    list1.insert(2, 11) - вставка нового элемента 11 в индекс 2

    list_1.pop() # удаляет последний элемент и возвращает его
    list_1.pop(i) # удаляет i-тый элемент и возвращает его

**`С Р Е З Ы`**
=============
    list_1 = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]

    print(list_1[0])                # 1й элемент
    print(list_1[1])                # 2й элемент
    print(list_1[len(list_1)-1])    # 1й с конца
    print(list_1[-5])               # 5й с конца
    print(list_1[:])                # ОТ начала ДО конца
    print(list_1[:2])               # [1, 2] - ОТ:ДО не включая
    print(list_1[len(list_1)-2:])   # ОТ 2го с конца ДО конца
    print(list_1[2:9])              # ОТ 2 ДО 9 НЕ ВКЛЮЧАЯ
    print(list_1[0:len(list_1):6])  # [1, 7] - от 0 до конца с шагом 6
    print(list_1[::6])              # [1, 7]

**`К О Р Т Е Ж И`**
=================
Кортеж - неизменяемый список.
Применяется в тех случаях, когда нужно гарантировать неизменяемость данных.
Обращение к элементам происходит по индексу (начиная с 0).


    t = ()                              # создание пустого кортежа
    print(type(t))                      # class <'tuple'> [tju:pl]
    t = (1,)                            # создание пустого кортежа. 
                    # ОБЯЗАТЕЛЬНО ЗАПЯТАЯ в конце, если 1 элемент
    
    t = tuple(colors)                   # преобразование в кортеж
    t = tuple(['red', 'green', 'blue']) # преобразует список [] в кортеж
    r, g, b = t                         # РАЗЪЕДИНЯЕТ кортеж на переменные
    t = tuple(['red', 'green', 'blue'])

    print(t[0])                              # red
    print('r:{} g:{} b:{}'.format(r, g, b))  # r:red g:green b:blue

**`С Л О В А Р И`**
=============
Словари — неупорядоченные коллекции произвольных объектов с
доступом по ключу. 
Типы ключей могут отличаться.

    dictionary = {}             # создание пустого словаря
    dictionary = dict()         # создание пустого словаря

    dictionary = {'up': '↑', 'left': '←', 'down': '↓', 'right': '→'}
    print(dictionary)           # {'up':'↑', 'left':'←', 'down':'↓', 'right':'→'}
    print(dictionary['left'])   # ←
    dictionary['left'] = 'qwe'  # присваивание значения элементу под ключом 'left'
                                # если ключа 'left' раньше не было, он будет создан
    del dictionary['left']      # удаление ключа вместе с элементом
    
    dictionary.items()          # представление словаря в виде списка кортежей
                                # dict_items([(key, element), (key, element), ... ])
    dictionary.values()         # вывод ЗНАЧЕНИЙ всех ключей
                                # dict_values([elem, elem, elem, ...])
    dictionary.keys()           # вывод всех КЛЮЧЕЙ (индексов) словаря
                                # dict_keys(['key', 'key', 'key', ...])

    for item in dictionary:
    ИЛИ 
    for (k, v) in dictionary.items():
    print('{}: {}'.format(item, dictionary[item]))

**`М Н О Ж Е С Т В А`**
=============

Множества содержат в себе уникальные элементы, не обязательно
упорядоченные.

    colors = set()              # СОЗДАНИЕ пустого множества
    colors = {'red', 'green', 'blue'} # СОЗДАНИЕ и заполнение множества
    colors.add('red')           # ДОБАВЛЕНИЕ элемента (добавится в рандомный индекс)
                                # если элемент уже был, ничего не произойдет
    colors.remove('red')        # УДАЛЕНИЕ элемента
                                # при попытке удаления несуществующего KeyError: 'red'
    colors.discard('red')       # для удаления любого элемента, в т.ч. несуществ
    colors.clear()              # УДАЛЕНИЕ ВСЕХ элементов

    a = {1, 2, 3, 5, 8}
    b = {2, 5, 8, 13, 21}
    c = a.copy()            # КОПИРОВАНИЕ одного множества в другое
    u = a.union(b)          # ОБЪЕДИНЕНИЕ (сливание) двух множеств
    i = a.intersection(b)   # ПЕРЕСЕЧЕНИЕ - элементы, которые есть в обоих множ-вах
    dl = a.difference(b)    # РАЗНОСТЬ - то, что входит в А, но не входит в Б: 
                            # dl = {1, 3} 
    dr = b.difference(a)    # РАЗНОСТЬ - то, что входит в Б, но не входит в А: 
                            # dr = {13, 21}
    q=a.union(b).difference(a.intersection(b))      # {1, 21, 3, 13}

Неизменяемое или замороженное множество(frozenset) — множество, с которым
не будут работать методы удаления и добавления.
    
    a = {1, 2, 3, 5, 8}
    b = frozenset(a)
    print(b) # frozenset({1, 2, 3, 5, 8})

![Сравнение коллекций](collections.jpg)

**`LIST COMPREHENSION`**
=========================

**`List comprehension`** — это упрощенный подход к созданию списка, который
задействует цикл `for`, а также инструкции `if-else` для определения того, что в итоге
окажется в финальном списке.

Простая ситуация — список:

    list_1 = [выражение for item in iterable]  *iterable - любая коллекция
    { key:value for item in list if conditional } - генератор словаря

Выборка по заданному условию:

    list_1 = [выражение for item in iterable (if условие)]
    list_1 = [i for i in range(1, 101)]                 # [1, 2, 3,..., 100]

Создать пары каждому из чисел (кортежи):

    list_1 = [(i, i) for i in range(1, 101) if i % 2 == 0] # [(2, 2), (4, 4),...,
    (100, 100)]

Можно умножать, делить, прибавлять, вычитать. Например, умножить значение на 2.

    list_1 = [i * 2 for i in range(10) if i % 2 == 0]

**`ОШИБКИ в PYTHON`**
============================
**`SyntaxError`**(Синтаксическая ошибка)
> Отсутствие двоеточия в конце строки

**`IndentationError`**(Ошибка отступов)
> Отсутствие отступов

**`TypeError`**(Типовая ошибка)
> Нельзя складывать строки и числа

**`ZeroDivisionError`**(Деление на 0)
> Деление на 0

**`KeyError`**(Ошибка ключа)
> Отсуствие ключа в словаре

**`NameError`**(Ошибка имени переменной)
> Переменной с указанным именем не существует

**`ValueError`**(Ошибка значения)
> Ошибка при невозможности преобразования одного типа в другой

