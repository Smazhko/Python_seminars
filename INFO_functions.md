![заголовок](pthn.png) **`Ф У Н К Ц И И`**
==========================

- название функции принято писать с маленькой буквы
- функции можно передать неизвестное сначала количество параметров:
      def function (*params):
          for i in args:
              res += i
      return res

      function ("q", "w", "e", "r", "t", "y", "0")
ПОСТАНОВКА ЗВЁЗДОЧКИ в списке аргументов обозначет, что в это место будет передан СПИСОК (работает ВЕЗДЕ)

Область видимости переменных или просто “Область видимости” (англ. variable scope или просто scope) — 
это такая область программы, в пределах которой установлена связь между некоторой переменной и её 
идентификатором (именем), по которому можно получить значение этой переменной

![заголовок](pthn.png) ## ЛЯМБДА lambda ФУНКЦИИ
-----------------------------
пишется в 1 строчку
в начале список ПЕРЕМЕННЫХ, потом ДВОЕТОЧИЕ, затем ВЫРАЖЕНИЕ с этими переменными
(lambda x: x**2)

МАР (функциональное программирование) - функция, в которую передается функция (ЛЯМБДА на месте 
или другая, прописанная из вне)
если есть ИТЕРИРУЕМЫЙ объект контейнер (может содержать разные объёкты в том числе 
самого себя - словари и прочие коллекции), МАР преобразует каждый элемент из коллекции
в соответствии с указанной функцией и возвращает НОВУЮ коллекцию с преобразованными элементами
list(map(lambda item: (1 if item > 3 else item), scoreList))

Подобным образом работают другие ФУНКЦИИ ВЫСШЕГО ПОРЯДКА (функции, которая принимает другие 
функции в качестве аргументов) filter(), reduce(), max()

Функция filter() в Python принимает в качестве аргументов функцию и список.
Функция вызывается со всеми элементами в списке, и в результате возвращается новый 
список, содержащий элементы, для которых функция результирует в True.
new_list = list(filter(lambda x: (x%2 == 0) , my_list))

Функция reduce() принимает в качестве аргументов функцию и список. Функция вызывается 
с помощью лямбда-функции и итерируемого объекта  и возвращается новый уменьшенный результат. 
Так выполняется повторяющаяся операцию над парами итерируемых объектов. 
Функция reduce() входит в состав модуля functools.
summa = reduce((lambda x, y: x + y), current_list)

-----------------
## Что такое args, kwargs. В каких случаях они требуются
-----------------
Выражения `*args` и `**kwargs` объявляют в сигнатуре функции. Они означают, что внутри функции будут доступны переменные с именами `args` и `kwargs` (без звездочек). Можно использовать другие имена, но это считается дурным тоном.

`args` – это кортеж, который накапливает позиционные аргументы. `kwargs` – словарь именованных аргументов, где ключ – имя параметра, значение – значение параметра.

**Важно:** если в функцию не передано никаких параметров, переменные будут соответственно равны пустому кортежу и пустому словарю, а не `None`.

Пожалуйста, не путайте кортеж со списком. Следующий вопрос объясняет, почему.

-----------------
## Почему использовать изменяемые объекты как параметры по-умолчанию плохо. Приведите пример плохого случая. Как исправить
-----------------

Функция создается однажды при загрузке модуля. Именованные параметры и их дефолтные значения тоже создаются один раз и хранятся в одном из полей объекта-функции.

В нашем примере `bar` равен пустому списку. Список – изменяемая коллекция, поэтому значение `bar` может изменяться от вызова к вызову. Пример:

```python
def foo(bar=[]):
    bar.append(1)
    return bar
foo()
>>> [1]
foo()
[1, 1]
foo()
>>> [1, 1, 1]
```

Хорошим тоном считается указывать параметру пустое неизменяемое значение, например `0`, `None`, `''`, `False`. В теле функции проверять на заполненность и создавать новую коллекцию:

```python
def foo(bar=None):
    if bar is None:
        bar = []
    bar.append(1)
    return bar
foo()
>>> [1]
foo()
>>> [1]
foo()
>>> [1]
```

Сказанное выше актуально в т.ч. для множеств и словарей.

-----------------
## Можно ли передавать функцию в качестве аргумента другой функции
-----------------

Можно, функция в Питоне объект первого порядка: допускает присваивание, передачу в функцию, удаление.

-----------------
## Можно ли объявлять функцию внутри другой функции. Где она будет видна
-----------------

Можно. Такая функция будет видна только внутри первой функции.

-----------------
## Что такое лямбды. Каковы их особенности
-----------------

Это анонимные функции. Они не резервируют имени в пространстве имен. Лямбды
часто передают в функции `map`, `reduce`, `filter`.

Лямбды в Питоне могут состоять только из одного выражения. Используя синтаксис
скобок, можно оформить тело лямбды в несколько строк.

Использовать точку с запятой для разделения операторов нельзя.

-----------------
## Допустимы ли следующие выражения
-----------------

- `nope = lambda: pass`
- `riser = lambda x: raise Exception(x)`

Нет, при загрузке модуля выскочит исключение `SyntaxError`. В теле лямбды может
быть только выражение. `pass` и `raise` являются операторами.

-----------------
## Как передаются значения аргументов в функцию или метод
-----------------

- [How do I write a function with output parameters (call by reference)?](https://docs.python.org/3/faq/programming.html#how-do-i-write-a-function-with-output-parameters-call-by-reference)
- [Интересности и полезности python. Часть 3](https://habr.com/ru/post/422951/)

В таких языках как C++ есть переменные, хранящиеся на стеке и в динамической памяти. При вызове функции мы помещаем все аргументы на стек, после чего передаём управление функции. Она знает размеры и смещения переменных на стеке, соответственно может их правильно интерпретировать.
При этом у нас есть два варианта: скопировать на стек память переменной или положить ссылку на объект в динамической памяти (или на более высоких уровнях стека).
Очевидно, что при изменении значений на стеке функции, значения в динамической памяти не поменяются, а при изменении области памяти по ссылке, мы модифицируем общую память, соответственно все ссылки на эту же область памяти «увидят» новое значение.

В python отказались от подобного механизма, заменой служит механизм *связывания (assignment)* имени переменной с объектом, например при создании переменной:
`var = "john"`

Интерпретатор создаёт объект «john» и «имя» var, а затем связывает объект с данным именем.
При вызове функции, новых объектов не создаётся, вместо этого в её области видимости создаётся имя, которое связывается с существующим объектом.
Но в python есть изменяемые и неизменяемые типы. Ко вторым, например, относятся числа: при арифметических операциях существующие объекты не меняются, а создаётся новый объект, с которым потом связывается существующее имя. Если же со старым объектом после этого не связано ни одного имени, оно будет удалено с помощью механизма подсчёта ссылок.
Если же имя связано с переменной изменяемого типа, то при операциях с ней изменяется память объекта, соответственно все имена, связанные с данной областью памяти «увидят» изменения.

-----------------
## Что такое замыкание
-----------------

Синтаксически это выглядит как функция, находящаяся целиком в теле другой функции. При этом вложенная внутренняя функция содержит ссылки на локальные переменные внешней функции. Каждый раз при выполнении внешней функции происходит создание нового экземпляра внутренней функции, с новыми ссылками на переменные внешней.

-----------------
