# Итераторы и генераторы

- [Генераторы-итераторы Python](https://xakep.ru/2014/10/06/generatora-iteratory-python/)
- [Итерируемый объект, итератор и генератор](https://habr.com/ru/post/337314/)

## Что такое контейнер
----------------------

Контейнер – это тип данных, который инкапсулирует в себе значения других типов. Списки, кортежи, множества, словари и т.д. являются контейнерами.

----------------------
## Что такое итерабельный объект
----------------------

*Итерабельный объект* (в оригинальной терминологии – «iterable») – это объект, который может возвращать значения по одному за раз.
Примеры: все контейнеры и последовательности (списки, строки и т.д.), файлы, а также экземпляры любых классов, в которых определён метод `__iter__()` или `__getitem__()`.
Итерабельные объекты могут быть использованы внутри цикла `for`, а также во многих других случаях, когда ожидается последовательность (функции `sum()`, `zip()`, `map()` и т.д.).

**Подробнее**:

Рассмотрим итерируемый объект (`Iterable`). В стандартной библиотеке он объявлен как абстрактный класс `collections.abc.Iterable`:

```python
class Iterable(metaclass=ABCMeta):

    __slots__ = ()

    @abstractmethod
    def __iter__(self):
        while False:
            yield None

    @classmethod
    def __subclasshook__(cls, C):
        if cls is Iterable:
            return _check_methods(C, "__iter__")
        return NotImplemented
```

У него есть абстрактный метод `__iter__` который должен вернуть объект итератора. И метод `__subclasshook__` который проверяет наличие у класса метод `__iter__`. Таким образом, получается, что итерируемый объект это любой объект который реализует метод `__iter__`

```python
class SomeIterable1(collections.abc.Iterable):
    def __iter__(self):
        pass

class SomeIterable2:
    def __iter__(self):
        pass

print(isinstance(SomeIterable1(), collections.abc.Iterable))
# True
print(isinstance(SomeIterable2(), collections.abc.Iterable))
# True
```

Но есть один момент, это функция `iter()`. Именно эту функцией использует например цикл for для получения итератора. Функция `iter()` в первую очередь для получения итератора из объекта, вызывает его метод `__iter__`. Если метод не реализован, то она проверяет наличие метода `__getitem__` и если он реализован, то на его основе создается итератор. `__getitem__` должен принимать индекс с нуля. Если не реализован ни один из этих методов, тогда будет вызвано исключение `TypeError`.

```python
from string import ascii_letters

class SomeIterable3:
    def __getitem__(self, key):
        return ascii_letters[key]

for item in SomeIterable3():
    print(item)
```

----------------------
## Что такое итератор
----------------------

*Итератор* (iterator) – это объект, который представляет поток данных. Повторяемый вызов метода `__next__()` (`next()` в Python 2) итератора или передача его встроенной функции `next()` возвращает последующие элементы потока.

Если больше не осталось данных, выбрасывается исключение `StopIteration`. После этого итератор исчерпан и любые последующие вызовы его метода `__next__()` снова генерируют исключение `StopIteration`.

Итераторы обязаны иметь метод `__iter__`, который возвращает сам объект итератора, так что любой итератор также является итерабельным объектом и может быть использован почти везде, где принимаются итерабельные объекты.

**Подробнее:**

Итераторы представлены абстрактным классом `collections.abc.Iterator`:

```python
class Iterator(Iterable):

    __slots__ = ()

    @abstractmethod
    def __next__(self):
        'Return the next item from the iterator. When exhausted, raise StopIteration'
        raise StopIteration

    def __iter__(self):
        return self

    @classmethod
    def __subclasshook__(cls, C):
        if cls is Iterator:
            return _check_methods(C, '__iter__', '__next__')
        return NotImplemented
```

`__next__` Возвращает следующий доступный элемент и вызывает исключение `StopIteration`, когда элементов не осталось.
`__iter__` Возвращает `self`. Это позволяет использовать итератор там, где ожидается итерируемых объект, например `for`.
`__subclasshook__` Проверяет наличие у класса метода `__iter__` и `__next__`

### Что такое генератор

В зависимости от контекста, может означать либо функцию-генератор, либо итератор генератора (чаще всего, последнее).
Методы `__iter__` и `__next__` у генераторов создаются автоматически.

С точки зрения реализации, *генератор* в Python — это языковая конструкция, которую можно реализовать двумя способами: как функция с ключевым словом `yield` или как генераторное выражение. В результате вызова функции или вычисления выражения, получаем объект-генератор типа `types.GeneratorType`. Канонический пример - генератор, порождающий последовательность чисел Фибоначчи, которая, будучи бесконечна, не смогла бы поместиться ни в одну коллекцию. Иногда термин применяется для самой генераторной функции, а не только объекта, возвращенного ей в качестве результата.

Так как в объекте-генераторе определены методы `__next__` и `__iter__`, то есть реализован протокол итератора, с этой точки зрения, в Python любой генератор является итератором.

Когда выполнение функции-генераторы завершается (при помощи ключевого слова `return` или достижения конца функции), возникает исключение `StopIteration`.

----------------------
## Что такое генераторная функция
----------------------

*Генераторная функция* - функция, в теле которой встречается ключевое слово `yield`. Будучи вызвана, такая функция возвращает объект-генератор (generator object) (итератор генератора (generator iterator)).

----------------------
## Что делает yield
----------------------

`yield` замораживает состояние функции-генератора и возвращает текущее значение. После следующего вызова `__next__()` функция-генератор продолжает своё выполнение с того места, где она была приостановлена.

----------------------
## В чем отличие \[x for x in y\] от (x for x in y)
----------------------

Первое выражение возвращает список (списковое включение), второе – генератор.

----------------------
## Что особенного в генераторе
----------------------

Генератор хранит в памяти не все элементы, а только внутреннее состояние для вычисления очередного элемента. На каждом шаге можно вычислить только следующий элемент, но не предыдущий. Пройти генератор в цикле можно только один раз.

----------------------
## Как объявить генератор
----------------------

- использовать синтаксис `(x for x in seq)`
- оператор `yield` в теле функции вместо `return`
- встроенная функция `iter`, которая вызывает у объекта метод `__iter__()`. Этот метод должен возвращать генератор.

----------------------
## Как получить из генератора список
----------------------

Передать его в конструктор списка: `list(x for x in some_seq)`. Важно, что после этого по генератору уже нельзя будет итерироваться.

----------------------
## Что такое подгенератор
----------------------

В Python 3 существуют так называемые подгенераторы (subgenerators). Если в функции-генераторе встречается пара ключевых слов `yield from`, после которых следует объект-генератор, то данный генератор делегирует доступ к подгенератору, пока он не завершится (не закончатся его значения), после чего продолжает своё исполнение.

На самом деле `yield` является выражением. Оно может принимать значения, которые отправляются в генератор. Если в генератор не отправляются значения, результат данного выражения равен `None`.

`yield from` также является выражением. Его результатом является то значение, которое подгенератор возвращает в исключении `StopIteration` (для этого значение возвращается при помощи ключевого слова `return`).

----------------------
## Какие методы есть у генераторов
----------------------

- `__next__()` – начинает или продолжает исполнение функции-генератора. Результат текущего yield-выражения будет равен None. Выполнение затем продолжается до следующего yield-выражения, которое передаёт значение туда, где был вызван `__next__`. Если генератор завершается без возврата значения при помощи `yield`, возникает исключение `StopIteration`. Метод обычно вызывается неявно, то есть циклом `for` или встроенной функцией `next()`.
- `send(value)` – продолжает выполнение и отправляет значение в функцию-генератор. Аргумент value становится значением текущего yield-выражения. Метод `send()` возвращает следующее значение, возвращённое генератором, или выбрасывает исключение `StopIteration`, если генератор завершается без возврата значения. Если `send()` используется для запуска генератора, то единственным допустимым значением является `None`, так как ещё не было выполнено ни одно yield-выражение, которому можно присвоить это значение.
- `throw(type[, value[, traceback]])` – выбрасывает исключение типа type в месте, где был приостановлен генератор, и возвращает следующее значение генератора (или выбрасывает `StopIteration`). Если генератор не обрабатывает данное исключение (или выбрасывает другое исключение), то оно выбрасывается в месте вызова.
- `close()` – выбрасывает исключение `GeneratorExit` в месте, где был приостановлен генератор. Если генератор выбрасывает `StopIteration` (путём нормального завершения или по причине того, что он уже закрыт) или `GeneratorExit` (путём отсутствия обработки данного исключения), `close` просто возвращается к месту вызова. Если же генератор возвращает очередное значение, выбрасывается исключение `RuntimeError`. Метод `close()` ничего не делает, если генератор уже завершён.

----------------------
## Можно ли извлечь элемент генератора по индексу
----------------------

Нет, будет ошибка. Генератор не поддерживает метод `__getitem__`.

----------------------
## Что возвращает итерация по словарю
----------------------

Ключ. Порядок следования ключей не гарантируется (в 3.6 гарантируется неофициально, в 3.7 гарантируется). Для маленьких словарей порядок будет тот же, что и в объявлении. Для больших порядок зависит от расположения элементов в памяти. Особый класс `OrderedDict` учитывает порядок добавления ключей.

```python
for key in {'foo': 1, 'bar': 2}:
    process_key(key)
```

----------------------
## Как итерировать словарь по парам ключ-значение
----------------------

Метод словаря `.items()` возвращает генератор кортежей `(key, value)`.

----------------------
## Что такое сопрограмма
----------------------

Сопрограмма (англ. coroutine) — компонент программы, обобщающий понятие подпрограммы, который дополнительно поддерживает множество входных точек (а не одну, как подпрограмма) и остановку и продолжение выполнения с сохранением определённого положения.
Расширенные возможности генераторов в Python (выражения yield и yield from, отправка значений в генераторы) используются для реализации сопрограмм.
Сопрограммы полезны для реализации асинхронных неблокирующих операций и кооперативной многозадачности в одном потоке без использования функций обратного вызова (callback-функций) и написания асинхронного кода в синхронном стиле.
Python 3.5 включает в себе поддержку сопрограмм на уровне языка. Для этого используются ключевые слова async и await.