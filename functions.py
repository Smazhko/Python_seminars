#  ЗАДАЧА =======================================================
# У вас есть код, который вы не можете менять(так часто бывает, когда код в глубине
# программы используется множество раз и вы не хотите ничего сломать):
# transformation = <???>
# values = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29] # или любой другой список
# transormed_values = list(map(transformation, values))
# Единственный способ вашего взаимодействия с этим кодом - посредством задания
# функции transformation.
# Однако вы поняли, что для вашей текущей задачи вам не нужно никак преобразовывать
# список значений, а нужно получить его как есть.
# Напишите такое лямбда-выражение transformation, чтобы transformed_values получился
# копией values.

'''
def transformation(values):
    return list(map(lambda x: x, values))

values = [1,2,3,4]
transformed_values = transformation(values)
print(transformed_values)
'''

# ЗАДАЧА =========================================================
# Планеты вращаются вокруг звезд по эллиптическим орбитам.
# Назовем самой далекой планетой ту, орбита которой имеет самую большую площадь. Напишите функцию
# find_farthest_orbit(list_of_orbits), которая среди списка орбит планет найдет ту, по которой 
# вращается самая далекая планета. Круговые орбиты не учитывайте: вы знаете, что у
# вашей звезды таких планет нет, зато искусственные спутники были были запущены на круговые орбиты. 
# Результатом функции должен быть кортеж, содержащий длины полуосей
# эллипса орбиты самой далекой планеты. Каждая орбита представляет из себя кортеж из пары чисел - 
# полуосей ее эллипса. Площадь эллипса вычисляется по формуле S = pi*a*b, где a и b - длины 
# полуосей эллипса. При решении задачи используйте списочные выражения. Подсказка: проще всего
# будет найти эллипс в два шага: сначала вычислить самую большую площадь эллипса, а затем найти 
# и сам эллипс, имеющий такую площадь. Гарантируется, что самая далекая планета ровно одна.
'''
# ВАРИАНТ 1
# from math import pi as PI

# def find_farthest_orbit(list_of_orbits):
#     maxArea = 0
#     a,b = list_of_orbits[1]

#     # for orbit in list_of_orbits:
#     #     a, b = orbit
#     #     if a != b:
#     #         currentArea = PI * a * b
#     #         if currentArea > maxArea:
#     #                 maxArea = currentArea
#     #                 farest = orbit
#     # return farest
        
# ВАРИАНТ 2
# orbits = [(1, 3), (2.5, 10), (7, 2), (6, 6), (4, 3)]
# print(find_farthest_orbit(orbits))
# print(sum(orbits))

# ВАРИАНТ 3
from math import pi

orbits = [(1, 3), (2.5, 10), (7, 2), (6, 6), (4, 3)]

p = max(orbits, key=lambda x: (x[0] != x[1]) * x[0] * x[1]*pi)
print(p)
'''
# Задача №51. Решение в группах
# Напишите функцию same_by(characteristic, objects), которая проверяет, все ли объекты 
# имеют одинаковое значение некоторой характеристики, и возвращают True, если это так.
# Если значение характеристики для разных объектов отличается - то False. Для пустого 
# набора объектов, функция должна возвращать True. Аргумент characteristic - это
# функция, которая принимает объект и вычисляет его характеристику.
# Ввод:                                     Вывод:
# values = [0, 2, 10, 6]                    same
# if same_by(lambda x: x % 2, values):
# print(‘same’)
# else:
# print(‘different’)

'''
import random as rnd

def isSimple(number):
    num = abs(number)
    if num == 0:
        return False
    if num == 1 or num == 2:
        return True
    for i in range(2,num):
        if num % i == 0:
            return False
    return True

def same_by(characteristic, checkingList):
    result = True
    for item in checkingList:
        result *= characteristic(item)
        if result == False:
            return result
    return result


# list1 = [-2, 0, 8, -8, 6, 2, 4, -4] # НЕпростые, НЕположительные, ЧЁТНЫЕ
list1 = [2, 3, 7, 11, 13, 29, 5]    # ПРОСТЫЕ, ПОЛОЖИТЕЛЬНЫЕ, НЕчётные
print("Генерируем список...")
print(list1)

characteristicDict = {1 : (lambda x: x % 2 == 0), 2 : (lambda x: x >= 0), 3: (lambda x: isSimple(x))}
characteristicList = ["Проверка на ЧЁТНОСТЬ" , "Проверка на ПОЛОЖИТЕЛЬНОТЬ", "Проверка на ПРОСТОТУ", "Выход"]

while(True):
    for i in range(len(characteristicList)):
        print(f"({i+1}) {characteristicList[i]}")
    check = int(input("Выберите проверку всех элементов списка... "))
    if check == 4:
        break
    if same_by(characteristicDict[check], list1):
        print(characteristicList[check-1] + " - УСПЕШНАЯ (все элементы удовлетворяют условию). \n")
    else:
        print(characteristicList[check-1] + " - ПРОВАЛИЛАСЬ (не все элементы удовлетворяют условию).\n")
'''

# Генерируем список...
# [2, 3, 7, 11, 13, 29, 5]
# (1) Проверка на ЧЁТНОСТЬ
# (2) Проверка на ПОЛОЖИТЕЛЬНОТЬ
# (3) Проверка на ПРОСТОТУ
# (4) Выход
# Выберите проверку всех элементов списка... 1
# Проверка на ЧЁТНОСТЬ - ПРОВАЛИЛАСЬ (не все элементы удовлетворяют условию).

# (1) Проверка на ЧЁТНОСТЬ
# (2) Проверка на ПОЛОЖИТЕЛЬНОТЬ
# (3) Проверка на ПРОСТОТУ
# (4) Выход
# Выберите проверку всех элементов списка... 2
# Проверка на ПОЛОЖИТЕЛЬНОТЬ - УСПЕШНАЯ (все элементы удовлетворяют условию). 

# (1) Проверка на ЧЁТНОСТЬ
# (2) Проверка на ПОЛОЖИТЕЛЬНОТЬ
# (3) Проверка на ПРОСТОТУ
# (4) Выход
# Выберите проверку всех элементов списка... 3
# Проверка на ПРОСТОТУ - УСПЕШНАЯ (все элементы удовлетворяют условию).
